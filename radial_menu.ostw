playervar define menuItems;
playervar define menuCenter; // The center of the menu relative to the player
playervar define menuItemPositions; // The positions of the menu items relative to the menu center
playervar define menuItemIDs; // The InWorldText IDs of the menu items
playervar define menuScale;
playervar define menuVisibleTo;
playervar define tmp; // Temporary variable. Don't rely on its content!!!

define menuDistanceFromPlayer: 2; // z-distance of the menu to the players eyes
define menuItemIconScale: 2.5; // Scale of the menu items
define menuCenterOffset: Vector(0,-0.150,0);
define menuAnimationTime: 0.2; // The time in which the menu is animated open/closed
define selectionRadius: 0.5; // Radius around menu items where they can be selected
define maxMenuScale: 0.2 + CountOf(AllowedHeroes()) * 0.03;

rule: "Init Player"
Event.OngoingPlayer
{
    updateMenu()
}

rule: "Open Menu"
Event.OngoingPlayer
if(IsButtonHeld(EventPlayer(), Button.Interact))
if(menuScale == 0)
{
    menuVisibleTo = EventPlayer()
    menuCenter = menuCenterOffset + menuDistanceFromPlayer * DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()), clamp(VerticalFacingAngleOf(EventPlayer()), -40, 40))
    ChaseVariableOverTime(menuScale, maxMenuScale, menuAnimationTime, TimeChaseReevaluation.None)
}

rule: "Close Menu"
Event.OngoingPlayer
if(!IsButtonHeld(EventPlayer(), Button.Interact))
if(menuScale > 0)
{
    ChaseVariableOverTime(menuScale, 0, menuAnimationTime, TimeChaseReevaluation.None)
    Wait(menuAnimationTime * 0.8)
    menuVisibleTo = []
}

rule: "Select Menu Item"
Event.OngoingPlayer
if(!IsButtonHeld(EventPlayer(), Button.Interact))
if(menuScale == maxMenuScale)
{
    tmp = getIndexOfSelectedMenuItem()
    if(tmp >= 0) {
        ForcePlayerHero(EventPlayer(), ValueInArray(AllowedHeroes(), tmp))
        StopForcingHero()
    }
}

void updateMenu() "Update Menu" {
    updateMenuItemPositions()
    updateMenuItemIcons() 
}

void updateMenuItemPositions() {
    menuItems = AllowedHeroes() // TODO Init menu items with tanks, supports and damage heroes
    menuItemPositions = []
    if(CountOf(AllowedHeroes()) <= 2) {
        menuItemPositions = [Left(), Right()]
    } else {
        for(tmp=0; CountOf(AllowedHeroes()); 1) {
            menuItemPositions[tmp] = Vector(
                SineFromDegrees((360/CountOf(AllowedHeroes())) * tmp),
                CosineFromDegrees((360/CountOf(AllowedHeroes())) * tmp),
                0
            )
        }
    }
}

void updateMenuItemIcons() {
    destroyMenuItems()
    menuItemIDs = []

    tmp = LastTextID() + 1

    // Create InWorldText
    Skip(30 - CountOf(AllowedHeroes()))
    createMenuItem(30)
    createMenuItem(29)
    createMenuItem(28)
    createMenuItem(27)
    createMenuItem(26)
    createMenuItem(25)
    createMenuItem(24)
    createMenuItem(23)
    createMenuItem(22)
    createMenuItem(21)
    createMenuItem(20)
    createMenuItem(19)
    createMenuItem(18)
    createMenuItem(17)
    createMenuItem(16)
    createMenuItem(15)
    createMenuItem(14)
    createMenuItem(13)
    createMenuItem(12)
    createMenuItem(11)
    createMenuItem(10)
    createMenuItem(9)
    createMenuItem(8)
    createMenuItem(7)
    createMenuItem(6)
    createMenuItem(5)
    createMenuItem(4)
    createMenuItem(3)
    createMenuItem(2)
    createMenuItem(1)
    createMenuItem(0)

    // Save IDs of successfully created InWorldTexts (no ID is created by OW if creation fails)
    for(tmp=tmp; LastTextID(); 1) {
         menuItemIDs = Append(menuItemIDs, tmp)
    }
}

void destroyMenuItems() {
    for(tmp=0; CountOf(menuItemIDs); 1) {
        DestroyInWorldText(menuItemIDs[tmp])
    }
}

void createMenuItem(ref define idx) {
    CreateInWorldText(
        menuVisibleTo,
        HeroIconString(menuItems[idx]),
        WorldVectorOf(
            LocalVectorOf(EyePosition() + menuCenter) + menuItemPositions[idx] * menuScale,
            EventPlayer()
        ),
        menuItemIconScale,
        Clipping.DoNotClip
    )
}

define getIndexOfSelectedMenuItem() {
    return IndexOfArrayValue(
        menuItemPositions,
        FirstOf(
            getMenuItemPositionsNearMouse(selectionRadius)
        )
    );
}

define getMenuItemPositionsNearMouse(ref define radius) {
    return FilteredArray(
        menuItemPositions,
        AngleBetweenVectors(
            FacingDirectionOf(), 
            DirectionTowards(
                EyePosition(),
                WorldVectorOf(
                    LocalVectorOf(EyePosition() + menuCenter - menuCenterOffset) + ArrayElement() * menuScale,
                    EventPlayer()
                ),
            )
        ) < radius
    );
}

/* Returns a number whose value is limited to the given range */
define clamp(ref define val, ref define min, ref define max) {
    return Min(max,Max(min,val));
}