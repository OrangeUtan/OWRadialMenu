playervar define menuItems;
playervar define menuCenter; // The center of the menu relative to the player
playervar define menuItemPositions; // The positions of the menu items relative to the menu center
playervar define menuItemIDs; // The InWorldText IDs of the menu items
playervar define menuAnimationScale;
playervar define menuVisibleTo;
playervar define tmp;

define menuDistanceFromPlayer: 2; // z-distance of the menu to the players eyes
define menuItemIconScale: 2.5; // Scale of the menu items
define halfIconHeight: Vector(0,0.150,0); // A rough estimate of half the height of menu items
define menuAnimationTime: 0.2; // The time in which the menu is animated open/closed
define selectionRadius: 0.5; // Radius around menu items where they can be selected

rule: "Init Player"
Event.OngoingPlayer
{
    updateMenu()
}

rule: "Open Menu"
Event.OngoingPlayer
if(IsButtonHeld(EventPlayer(), Button.Interact))
if(menuAnimationScale == 0)
{
    menuVisibleTo = EventPlayer()
    menuCenter = menuDistanceFromPlayer * DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()), clamp(VerticalFacingAngleOf(EventPlayer()), -40, 40))
    ChaseVariableOverTime(menuAnimationScale, 1, menuAnimationTime, TimeChaseReevaluation.None)
}

rule: "Close Menu"
Event.OngoingPlayer
if(!IsButtonHeld(EventPlayer(), Button.Interact))
if(menuAnimationScale > 0)
{
    ChaseVariableOverTime(menuAnimationScale, 0, menuAnimationTime, TimeChaseReevaluation.None)
    Wait(menuAnimationTime * 0.8)
    menuVisibleTo = []
}

rule: "Select Menu Item"
Event.OngoingPlayer
if(!IsButtonHeld(EventPlayer(), Button.Interact))
if(menuAnimationScale == 1)
{
    tmp = getIndexOfSelectedMenuItem()
    SmallMessage(EventPlayer(), tmp)
    if(tmp >= 0) {
        ForcePlayerHero(EventPlayer(), ValueInArray(AllowedHeroes(), tmp))
        StopForcingHero()
    }
}

void updateMenu() "Update Menu" {
    updateMenuItemPositions()
    updateMenuItemIcons() 
}

void updateMenuItemPositions() {
    menuItems = AllowedHeroes() // TODO Init menu items with tanks, supports and damage heroes
    menuItemPositions = []
    if(CountOf(AllowedHeroes()) <= 2) {
        menuItemPositions = [Left(), Right()]
    } else {
        for(tmp=0; CountOf(AllowedHeroes()); 1) {
            menuItemPositions[tmp] = Vector(
                SineFromDegrees((360/CountOf(AllowedHeroes())) * tmp),
                CosineFromDegrees((360/CountOf(AllowedHeroes())) * tmp),
                0
            )
        }
    }
}

void updateMenuItemIcons() {
    destroyMenuItems()
    menuItemIDs = []
    for(tmp=0; CountOf(menuItems); 1) {
        // Create InWorldText
        if(tmp==0) createMenuItem(0)
        else if(tmp==1) createMenuItem(1)
        else if(tmp==2) createMenuItem(2)
        else if(tmp==3) createMenuItem(3)
        else if(tmp==4) createMenuItem(4)
        else if(tmp==5) createMenuItem(5)
        else if(tmp==6) createMenuItem(6)
        else if(tmp==7) createMenuItem(7)
        else if(tmp==8) createMenuItem(8)
        else if(tmp==9) createMenuItem(9)
        else if(tmp==10) createMenuItem(10)
        else if(tmp==11) createMenuItem(11)
        else if(tmp==12) createMenuItem(12)
        else if(tmp==13) createMenuItem(13)
        else if(tmp==14) createMenuItem(14)
        else if(tmp==15) createMenuItem(15)
        else if(tmp==16) createMenuItem(16)
        else if(tmp==17) createMenuItem(17)
        else if(tmp==18) createMenuItem(18)
        else if(tmp==19) createMenuItem(19)
        else if(tmp==20) createMenuItem(20)
        else if(tmp==21) createMenuItem(21)
        else if(tmp==22) createMenuItem(22)
        else if(tmp==23) createMenuItem(23)
        else if(tmp==24) createMenuItem(24)
        else if(tmp==25) createMenuItem(25)
        else if(tmp==26) createMenuItem(26)
        else if(tmp==27) createMenuItem(27)
        else if(tmp==28) createMenuItem(28)
        else if(tmp==29) createMenuItem(29)
        else if(tmp==30) createMenuItem(30)

        // Store the InWorldText ID
        menuItemIDs = Append(menuItemIDs, LastTextID())
    }
}

void destroyMenuItems() {
    for(tmp=0; CountOf(menuItemIDs); 1) {
        DestroyInWorldText(menuItemIDs[tmp])
    }
}

void createMenuItem(ref define idx) {
    CreateInWorldText(
        menuVisibleTo,
        HeroIconString(menuItems[idx]),
        WorldVectorOf(
            LocalVectorOf(EyePosition() + menuCenter) + menuItemPositions[idx] * menuAnimationScale,
            EventPlayer()
        ),
        menuItemIconScale,
        Clipping.DoNotClip
    )
}

define getIndexOfSelectedMenuItem() {
    return IndexOfArrayValue(
        menuItemPositions,
        FirstOf(
            getMenuItemPositionsNearMouse(selectionRadius)
        )
    );
}

define getMenuItemPositionsNearMouse(ref define radius) {
    return FilteredArray(
        menuItemPositions,
        AngleBetweenVectors(
            FacingDirectionOf(), 
            DirectionTowards(
                EyePosition(),
                WorldVectorOf(
                    LocalVectorOf(EyePosition() + menuCenter + halfIconHeight) + ArrayElement(),
                    EventPlayer()
                ),
            )
        ) < radius
    );
}

/* Returns a number whose value is limited to the given range */
define clamp(ref define val, ref define min, ref define max) {
    return Min(max,Max(min,val));
}